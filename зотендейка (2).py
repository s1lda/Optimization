# -*- coding: utf-8 -*-
"""Зотендейка.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cK18Vrn2Xjcx0e0PAweqOnhCeBLF4IY6

# метод Зойтендейка
"""

def f(x):

    return x[0]**2 - x[1]**2

def constraint(x):

    return 2*x[0] + x[1] - 3


def penalty_function(x, penalty_coefficient):

    # Вычисляем значение функции ограничения
    constraint_value = constraint(x)

    # Применяем штраф, если ограничение не выполняется
    penalty = max(0, constraint_value)**2

    # Добавляем штраф к целевой функции
    penalty_term = penalty_coefficient * penalty

    # Возвращаем значение штрафной функции
    return f(x) + penalty_term


def optimize_penalty_method(initial_guess, penalty_coefficient, tolerance=1e-6, max_iterations=1000, step_size=0.1):

    x = initial_guess

    for _ in range(max_iterations):
        # Вычисляем градиент штрафной функции
        gradient = [2*x[0], 2*x[1]]  # Градиент целевой функции
        constraint_gradient = [3, 1]  # Градиент функции ограничения

        # Обновляем переменные в направлении антиградиента
        for i in range(len(x)):
            x[i] -= step_size * (gradient[i] + penalty_coefficient * max(0, constraint(x)) * constraint_gradient[i])

        # Проверяем условие остановки
        if max(abs(gradient[0]), abs(gradient[1])) < tolerance:
            break

    return x

initial_guess = [0, 0]  # Начальное предположение
penalty_coefficient = 1000  # Коэффициент штрафа

optimal_solution = optimize_penalty_method(initial_guess, penalty_coefficient)
print("Минимум функции:", f(optimal_solution))
print("x, y:", optimal_solution)